"""
Python bindings to libFNR from Cisco.

For description of pyFNR see https://github.com/lacike/pyfnr
For description of libFNR see https://github.com/cisco/libfnr
"""
import ctypes
import math

_libfnr = ctypes.cdll.LoadLibrary('libfnr.so')
_libssl = ctypes.cdll.LoadLibrary('libssl.so')

KEY_SIZE = 32 #bytes
SALT_SIZE = 32 #bytes

class _FNR_expanded_tweak(ctypes.Structure):
	_fields_ = [("tweak", ctypes.c_ubyte * 15)] 

class FNR(object):
	"""
	FNR([key[, tweak[, block_size[, salt]]]]) -> FNR object

	LibFNR wrapper with methods for enciphering/deciphering strings,
	integers, bytearrays and raw c_char_Arrays.

	Keyword arguments:
	key -- string key ("password"). Constructor determines FNR key
		used for encryption and decryption from this parameter 
		by OpenSSL's PKCS5_PBKDF2_HMAC_SHA1() and libFNR's
		FNR_expand_key().
		FNR expanded key has a size of KEY_SIZE bytes.
		This param should be shared between encryptor and decryptor
		and kept in secret from anyone else.
	tweak -- additional string parameter, such a "public part of key".
		Tweak together with key determines exact permutation which will
		be realized by this encryption.
		With different tweaks we can use the same key for encryption
		of different entities and there will be	no relation between
		ciphertext and plaintext of these entities.
	block_size -- size of block (in bits) of plaintext/ciphertext which
		will be encrypted/decrypted using given credentials.
	salt -- optional parameter used for determining key in OpenSSL's
		PKCS5_PBKDF2_HMAC_SHA1(). Salt should be a string withsize of 
		SALT_SIZE bytes. Can be generated by generate_salt() function.
	"""

	_block_size = 32 # bits
	_block_size_bytes = 4
	_raw_type = ctypes.c_char * _block_size_bytes

	_fnr_expanded_key = None
	_fnr_tweak = _FNR_expanded_tweak()
	#_fnr_tweak = ctypes.create_string_buffer(15)

	def __init__(self, key="0000000000000000", tweak="tweak-is-string", block_size=32, salt=""): #block_size: bites
		"""
		Constructor of FNR class. For parameter description see FNR.__doc__
		
		This constructor initializes libFNR with FNR_init() and determines
		master_key from parameters key and salt using OpenSSL's
		PKCS5_PBKDF2_HMAC_SHA1(). Then determines FNR_expanded_key from
		master_key using libFNR's FNR_expand_key and determines
		FNR_expanded_tweak from parameter tweak by lib$FNR's
		FNR_expand_tweak.
		"""
		self._block_size = block_size
		self._block_size_bytes = int(math.ceil(1.0 * self._block_size / 8))
		self._raw_type = ctypes.c_char*self._block_size_bytes

		master_key = ctypes.create_string_buffer(KEY_SIZE)
		raw_key = ctypes.create_string_buffer(key)
		raw_salt = ctypes.create_string_buffer(salt, SALT_SIZE)
		raw_tweak = ctypes.create_string_buffer(tweak)

		if (_libssl.PKCS5_PBKDF2_HMAC_SHA1(raw_key, len(raw_key), raw_salt, SALT_SIZE, 1000, KEY_SIZE, master_key) != 1):
			raise EnvironmentError("call to OpenSSL's PKCS5_PBKDF2_HMAC_SHA1 failed")

		_libfnr.FNR_init()
		self._fnr_expanded_key = _libfnr.FNR_expand_key(master_key, KEY_SIZE*8, self._block_size)
		if (not self._fnr_expanded_key):
			raise EnvironmentError("call to fnr_expanded_key failed")

		_libfnr.FNR_expand_tweak(ctypes.byref(self._fnr_tweak), self._fnr_expanded_key, raw_tweak, len(raw_tweak))


	def close(self):
		"""
			Releases resources used by libFNR such as FNR_expanded_key.
		"""
		_libfnr.FNR_release_key(self._fnr_expanded_key)
		_libfnr.FNR_shut()

	def encrypt_raw(self, plaintext, ciphertext):
		"""
		encrypt_raw(ctypes.c_char_Array_N, ctypes.c_char_Array_N)

		Direct call to libFNR's FNR_encrypt()
		Encrypts given plaintext using libFNR's FNR_encrypt() with key and
		tweak determined during initialization.

		plaintext -- ctypes.c_char_Array_N object to be encrypted.
			N have to be ceil(block_size/8)
		ciphertext -- ctypes.c_char_Array_N object to store the result.
			N have to be ceil(block_size/8)
		"""
		_libfnr.FNR_encrypt(self._fnr_expanded_key, ctypes.byref(self._fnr_tweak), plaintext, ciphertext)

	def decrypt_raw(self, ciphertext, plaintext):
		"""
		decrypt_raw(ctypes.c_char_Array_N, ctypes.c_char_Array_N)

		Direct call to libFNR's FNR_decrypt().
		Decrypts given ciphertext using libFNR's FNR_decrypt() with key and
		tweak determined during initialization.

		ciphertext -- ctypes.c_char_Array_N object to be decrypted.
			N have to be ceil(block_size/8)
		plaintext -- ctypes.c_char_Array_N object to store the result.
			N have to be ceil(block_size/8)
		"""
		_libfnr.FNR_decrypt(self._fnr_expanded_key, ctypes.byref(self._fnr_tweak), ciphertext, plaintext)

	
	def encrypt_bytes(self, plaintext): # plaintext: bytearray
		"""
		encrypt_bytes(bytearray) -> bytearray

		Encrypts given plaintext using libFNR's FNR_encrypt() with key and
		tweak determined during initialization.

		plaintext -- bytearray to be encrypted. It should have size
			at least ceil(block_size/8) bytes 
		"""
		raw_plaintext = self._raw_type.from_buffer(plaintext)
		raw_ciphertext = ctypes.create_string_buffer(self._block_size_bytes)

		_libfnr.FNR_encrypt(self._fnr_expanded_key, ctypes.byref(self._fnr_tweak), raw_plaintext, raw_ciphertext)

		return bytearray(raw_ciphertext.raw)

	def decrypt_bytes(self, ciphertext): # ciphertext: bytearray
		"""
		decrypt_bytes(bytearray) -> bytearray

		Decrypts given ciphertext using libFNR's FNR_decrypt() with key and
		tweak determined during initialization.

		ciphertext -- bytearray to be decrypted. It should have size
			at least ceil(block_size/8) bytes 
		"""
		raw_plaintext = ctypes.create_string_buffer(self._block_size_bytes)
		raw_ciphertext = self._raw_type.from_buffer(ciphertext)

		_libfnr.FNR_decrypt(self._fnr_expanded_key, ctypes.byref(self._fnr_tweak), raw_ciphertext, raw_plaintext)

		return bytearray(raw_plaintext.raw)

	def encrypt_str(self, plaintext, strip=True):
		"""
		encrypt_str(str[, strip]) -> str

		Encrypts given plaintext with key and tweak determined during 
		initialization. Converts string to bytearray, uses encrypt_bytes()
		and converts bytearray to string.

		plaintext -- string to be encrypted.
		strip -- if True, then trailing zero bytes are removed from
			produced ciphertext
		"""
		padded_plaintext = plaintext + '\x00' * (self._block_size_bytes - len(plaintext))
		bytes_plaintext = self._str_to_bytes(padded_plaintext)
		bytes_ciphertext = self.encrypt_bytes(bytes_plaintext)
		padded_ciphertext = self._bytes_to_str(bytes_ciphertext)
		ciphertext= padded_ciphertext.rstrip('\x00') if strip else padded_ciphertext

		return ciphertext

	def decrypt_str(self, ciphertext, strip=True):
		"""
		decrypt_str(str[, strip]) -> str

		Decrypts given ciphertext with key and tweak determined during 
		initialization. Converts string to bytearray, uses decrypt_bytes()
		and converts bytearray to string.

		ciphertext -- string to be decrypted.
		strip -- if True, then trailing zero bytes are removed from
			produced plaintext
		"""
		padded_ciphertext = ciphertext + '\x00' * (self._block_size_bytes - len(ciphertext))
		bytes_ciphertext = self._str_to_bytes(padded_ciphertext)
		bytes_plaintext = self.decrypt_bytes(bytes_ciphertext)
		padded_plaintext = self._bytes_to_str(bytes_plaintext)
		plaintext = padded_plaintext.rstrip('\x00') if strip else padded_plaintext

		return plaintext

	def encrypt_int(self, plaintext):
		"""
		encrypt_int(int) -> int

		Encrypts given plaintext with key and tweak determined during 
		initialization. Converts int to bytearray, uses encrypt_bytes()
		and converts bytearray to int. Using signed integers are possible,
		but returned values are unsigned. Negative values can be obtained
		with two's complement.

		plaintext -- int to be encrypted.
		"""
		ciphertext = self.encrypt_bytes(self._int_to_bytes(plaintext))

		return self._bytes_to_int(ciphertext)

	def decrypt_int(self, ciphertext):
		"""
		decrypt_int(int) -> int

		Decrypts given ciphertext with key and tweak determined during 
		initialization. Converts int to bytearray, uses decrypt_bytes()
		and converts bytearray to int. Using signed integers are possible,
		but returned values are unsigned. Negative values can be obtained
		with two's complement.

		ciphertext -- int to be decrypted.
		"""
		plaintext = self.decrypt_bytes(self._int_to_bytes(ciphertext))

		return self._bytes_to_int(plaintext)

	# conversions str <-> bytearrays, because direct conversion ctypes.c_char_Array_N -> str via .value is not sufficient (problem with leading '\x00')
	def _str_to_bytes(self, strval):
		return bytearray([ord(x) for x in strval])

	def _bytes_to_str(self, bytesval):
		return "".join(map(chr, bytesval))

	def _int_to_bytes2(self, intval):
		hexval = "{0:x}".format(intval)
		hexval = "0"*(self._block_size_bytes*2 - len(hexval)) + hexval # padding with 0s 
		try:
			bytesval = bytearray.fromhex(hexval)
		except TypeError:
			# workaround for Python 2.6 unicode requirement
			bytesval = bytearray.fromhex(unicode(hexval))	
		bytesval.reverse() # little endian

		return bytesval

	def _int_to_bytes(self, intval):
		bytelist = [(intval & (0xff << 8*byte)) >> 8*byte for byte in range(self._block_size_bytes)]
		return bytearray(bytelist)

	def _bytes_to_int2(self, bytesval):
		bytesval_copy = bytearray(bytesval)
		bytesval_copy.reverse() # little endian
		strval = self._bytes_to_str(bytesval_copy)
		return int(strval.encode("hex"), 16)

	def _bytes_to_int(self, bytesval):
		intval = 0
		for byte in range(self._block_size_bytes):
			intval *= 0x100
			intval += bytesval[self._block_size_bytes-byte-1]
		return intval

class FNR2(object):
	"""
	FNR2([key[, tweak[, domain[, salt]]]]) -> FNR2 object

	FNR wrapper with cycle walking method for extending FNR enciphering
	scheme to all size of domains < 2**128, not only for sizes which are
	powers of two (2**block_size).

	Keyword arguments:
	key -- string key ("password"). Constructor determines FNR key
		used for encryption and decryption from this parameter 
		by OpenSSL's PKCS5_PBKDF2_HMAC_SHA1() and libFNR's
		FNR_expand_key().
		FNR expanded key has a size of KEY_SIZE bytes.
		This param should be shared between encryptor and decryptor
		and kept in secret from anyone else.
	tweak -- additional string parameter, such a "public part of key".
		Tweak together with key determines exact permutation which will
		be realized by this encryption.
		With different tweaks we can use the same key for encryption
		of different entities and there will be no relation between
		ciphertext and plaintext of these entities.
	domain -- specify desired domain for this enciphering.
		All plaintext and ciphertext are interpreted as unsigned
		integers from range [domain] = 0..domain.
	salt -- optional parameter used for determining key in OpenSSL's
		PKCS5_PBKDF2_HMAC_SHA1(). Salt should be a string withsize of 
		SALT_SIZE bytes. Can be generated by generate_salt() function.
	"""
	_fnr = None
	domain = 0

	def __init__(self, key="0000000000000000", tweak="tweak-is-string", domain=2**32-1, salt=""): # uses domain [domain]=0..domain
		self.domain = domain
		block_size = int(math.ceil(math.log(self.domain + 1, 2)))
		self._fnr = FNR(key, tweak, block_size, salt)

	def close(self):
		self._fnr.close()

	def encrypt(self, plaintext):
		"""
		encrypt(int) -> int

		Encrypts given plaintext using underlaying FNR encryption and
		cycle walking method.

		plaintext -- unsigned int to be encrypted.
		"""
		ciphertext = self._fnr.encrypt_int(plaintext)
		while (ciphertext > self.domain):
			ciphertext = self._fnr.encrypt_int(ciphertext)

		return ciphertext

	def decrypt(self, ciphertext):
		"""
		decrypt(int) -> int

		Decrypts given ciphertext using underlaying FNR decryption and
		cycle walking method.

		ciphertext -- unsigned int to be decrypted.
		"""
		plaintext = self._fnr.decrypt_int(ciphertext)
		while (plaintext > self.domain):
			plaintext = self._fnr.decrypt_int(plaintext)

		return plaintext

def generate_salt():
	"""
	generate_salt() -> str

	Generates salt of SALT_SIZE size using OpenSSL's RAND_bytes().
	"""
	salt = ctypes.create_string_buffer(SALT_SIZE)
	if (_libssl.RAND_bytes(salt, SALT_SIZE) != 1 ):
		raise EnvironmentError("call to OpenSSL's RAND_bytes failed")
	return salt.raw
